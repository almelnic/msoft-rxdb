{"version":3,"file":"rx-storage-instance-mongodb.js","names":["_rxjs","require","_rxSchemaHelper","_index","_mongodb","_rxStorageHelper","_mongodbHelper","RxStorageInstanceMongoDB","exports","storage","databaseName","collectionName","schema","internals","options","settings","changes$","Subject","runningOperations","BehaviorSubject","writeQueue","PROMISE_RESOLVE_VOID","mongoObjectIdCache","WeakMap","attachments","Error","primaryPath","getPrimaryFieldOfPrimaryKey","primaryKey","inMongoPrimaryPath","MONGO_ID_SUBSTITUTE_FIELDNAME","mongoClient","MongoClient","databaseSettings","connection","mongoDatabase","db","version","indexes","slice","map","index","arIndex","isMaybeReadonlyArray","push","mongoCollectionPromise","createCollection","then","mongoCollection","createIndexes","mongoIndex","forEach","field","name","getMongoDBIndexName","key","_proto","prototype","bulkWrite","documentWrites","context","next","getValue","closed","Promise","reject","ret","error","docIds","d","document","documentStates","findDocumentsById","documentStatesMap","Map","doc","docId","set","categorized","categorizeBulkWriteRows","changeByDocId","eventBulk","events","change","documentId","errors","all","bulkInsertDocs","writeRow","writeResult","findOneAndUpdate","$setOnInsert","swapRxDocToMongo","upsert","includeResultMetadata","value","conflictError","status","documentInDb","swapMongoToRxDoc","ensureNotFalsy","isError","event","get","bulkUpdateDocs","findOneAndReplace","_rev","previous","returnDocument","ok","currentDocState","currentDoc","getFromMapOrThrow","length","lastState","newestRow","checkpoint","id","lwt","_meta","endTime","now","withDeleted","session","plainQuery","$in","_deleted","result","queryResult","find","toArray","row","query","originalPreparedQuery","preparedQuery","prepareMongoDBQuery","mongoSelector","skip","limit","sort","mongoSort","resultDocs","documents","count","countDocuments","mode","cleanup","minimumDeletedTime","maxDeletionTime","deleteMany","$lt","getAttachmentData","_documentId","_attachmentId","_digest","changeStream","remove","drop","close","requestIdlePromise","firstValueFrom","pipe","filter","c","conflictResultionTasks","resolveConflictResultionTask","_taskSolution","createMongoDBStorageInstance","params","instance","resolve"],"sources":["../../../../src/plugins/storage-mongodb/rx-storage-instance-mongodb.ts"],"sourcesContent":["import {\r\n    BehaviorSubject,\r\n    Observable,\r\n    Subject,\r\n    filter,\r\n    firstValueFrom\r\n} from 'rxjs';\r\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper.ts';\r\nimport type {\r\n    BulkWriteRow,\r\n    EventBulk,\r\n    PreparedQuery,\r\n    RxConflictResultionTask,\r\n    RxConflictResultionTaskSolution,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxStorageBulkWriteResponse,\r\n    RxStorageChangeEvent,\r\n    RxStorageCountResult,\r\n    RxStorageDefaultCheckpoint,\r\n    RxStorageInstance,\r\n    RxStorageInstanceCreationParams,\r\n    RxStorageQueryResult,\r\n    RxStorageWriteErrorConflict,\r\n    StringKeys\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    ensureNotFalsy,\r\n    getFromMapOrThrow,\r\n    isMaybeReadonlyArray,\r\n    now,\r\n    PROMISE_RESOLVE_VOID,\r\n    requestIdlePromise\r\n} from '../../plugins/utils/index.ts';\r\nimport {\r\n    MongoDBStorageInternals,\r\n    MongoQuerySelector,\r\n    RxStorageMongoDBInstanceCreationOptions,\r\n    RxStorageMongoDBSettings\r\n} from './mongodb-types.ts';\r\nimport { RxStorageMongoDB } from './rx-storage-mongodb.ts';\r\nimport {\r\n    Db as MongoDatabase,\r\n    Collection as MongoCollection,\r\n    MongoClient,\r\n    ObjectId,\r\n    ClientSession\r\n} from 'mongodb';\r\nimport { categorizeBulkWriteRows } from '../../rx-storage-helper.ts';\r\nimport {\r\n    MONGO_ID_SUBSTITUTE_FIELDNAME,\r\n    getMongoDBIndexName,\r\n    prepareMongoDBQuery,\r\n    swapMongoToRxDoc,\r\n    swapRxDocToMongo\r\n} from './mongodb-helper.ts';\r\n\r\nexport class RxStorageInstanceMongoDB<RxDocType> implements RxStorageInstance<\r\n    RxDocType,\r\n    MongoDBStorageInternals,\r\n    RxStorageMongoDBInstanceCreationOptions,\r\n    RxStorageDefaultCheckpoint\r\n> {\r\n\r\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\r\n    public readonly inMongoPrimaryPath: string;\r\n    public closed?: Promise<void>;\r\n    private readonly changes$: Subject<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> = new Subject();\r\n    public readonly mongoClient: MongoClient;\r\n    public readonly mongoDatabase: MongoDatabase;\r\n    public readonly mongoCollectionPromise: Promise<MongoCollection<RxDocumentData<RxDocType> | any>>;\r\n    // public mongoChangeStream?: MongoChangeStream<any, ChangeStreamDocument<any>>;\r\n\r\n\r\n    /**\r\n     * Closing the connection must not happen when\r\n     * an operation is running, otherwise we get an error.\r\n     * So we store all running operations here so that\r\n     * they can be awaited.\r\n     */\r\n    public readonly runningOperations = new BehaviorSubject(0);\r\n    public writeQueue: Promise<any> = PROMISE_RESOLVE_VOID;\r\n\r\n    /**\r\n     * We use this to be able to still fetch\r\n     * the objectId after transforming the document from mongo-style (with _id)\r\n     * to RxDB\r\n     */\r\n    public readonly mongoObjectIdCache = new WeakMap<RxDocumentData<RxDocType>, ObjectId>();\r\n\r\n    constructor(\r\n        public readonly storage: RxStorageMongoDB,\r\n        public readonly databaseName: string,\r\n        public readonly collectionName: string,\r\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\r\n        public readonly internals: MongoDBStorageInternals,\r\n        public readonly options: Readonly<RxStorageMongoDBInstanceCreationOptions>,\r\n        public readonly settings: RxStorageMongoDBSettings\r\n    ) {\r\n        if (this.schema.attachments) {\r\n            throw new Error('attachments not supported in mongodb storage, make a PR if you need that');\r\n        }\r\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\r\n        this.inMongoPrimaryPath = this.primaryPath === '_id' ? MONGO_ID_SUBSTITUTE_FIELDNAME : this.primaryPath;\r\n        this.mongoClient = new MongoClient(storage.databaseSettings.connection);\r\n        this.mongoDatabase = this.mongoClient.db(databaseName + '-v' + this.schema.version);\r\n\r\n        const indexes = (this.schema.indexes ? this.schema.indexes.slice() : []).map(index => {\r\n            const arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];\r\n            return arIndex;\r\n        });\r\n        indexes.push([this.inMongoPrimaryPath]);\r\n\r\n        this.mongoCollectionPromise = this.mongoDatabase.createCollection(collectionName)\r\n            .then(async (mongoCollection) => {\r\n                await mongoCollection.createIndexes(\r\n                    indexes.map(index => {\r\n                        const mongoIndex: any = {};\r\n                        index.forEach(field => mongoIndex[field] = 1);\r\n                        return { name: getMongoDBIndexName(index), key: mongoIndex };\r\n                    })\r\n                );\r\n\r\n                /**\r\n                 * TODO in a setup where multiple servers run node.js\r\n                 * processes that use the mongodb storage, we should propagate\r\n                 * events by listening to the mongodb changestream.\r\n                 * This maybe should be a premium feature.\r\n                 */\r\n                // this.mongoChangeStream = mongoCollection.watch(\r\n                //     undefined, {\r\n                //     batchSize: 100\r\n                // }\r\n                // ).on('change', change => {\r\n\r\n\r\n                //     const eventBulkId = randomCouchString(10);\r\n                //     const newDocData: RxDocumentData<RxDocType> = (change as any).fullDocument;\r\n                //     const documentId = newDocData[this.primaryPath] as any;\r\n\r\n                //     const eventBulk: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint> = {\r\n                //         checkpoint: {\r\n                //             id: newDocData[this.primaryPath] as any,\r\n                //             lwt: newDocData._meta.lwt\r\n                //         },\r\n                //         context: 'mongodb-write',\r\n                //         id: eventBulkId,\r\n                //         events: [{\r\n                //             documentData: newDocData,\r\n                //             documentId,\r\n                //             operation: 'INSERT',\r\n                //             previousDocumentData: undefined,\r\n                //         }],\r\n                //             startTime: now(),\r\n                //             endTime: now()\r\n                //     };\r\n\r\n                //     this.changes$.next(eventBulk);\r\n                // });\r\n\r\n\r\n                return mongoCollection;\r\n            });\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Bulk writes on the mongodb storage.\r\n     * Notice that MongoDB does not support cross-document transactions\r\n     * so we have to do a update-if-previous-is-correct like operations.\r\n     * (Similar to what RxDB does with the revision system)\r\n     */\r\n    bulkWrite(\r\n        documentWrites: BulkWriteRow<RxDocType>[],\r\n        context: string\r\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\r\n\r\n        this.writeQueue = this.writeQueue.then(async () => {\r\n            this.runningOperations.next(this.runningOperations.getValue() + 1);\r\n\r\n            const mongoCollection = await this.mongoCollectionPromise;\r\n            if (this.closed) {\r\n                return Promise.reject(new Error('already closed'));\r\n            }\r\n            const primaryPath = this.primaryPath;\r\n            const ret: RxStorageBulkWriteResponse<RxDocType> = {\r\n                error: []\r\n            };\r\n\r\n\r\n            const docIds = documentWrites.map(d => (d.document as any)[primaryPath]);\r\n            const documentStates = await this.findDocumentsById(\r\n                docIds,\r\n                true\r\n            );\r\n            const documentStatesMap = new Map();\r\n            documentStates.forEach(doc => {\r\n                const docId = doc[primaryPath];\r\n                documentStatesMap.set(docId, doc);\r\n            });\r\n            const categorized = categorizeBulkWriteRows<RxDocType>(\r\n                this,\r\n                primaryPath as any,\r\n                documentStatesMap,\r\n                documentWrites,\r\n                context\r\n            );\r\n\r\n            const changeByDocId = new Map<string, RxStorageChangeEvent<RxDocumentData<RxDocType>>>();\r\n            categorized.eventBulk.events.forEach(change => {\r\n                changeByDocId.set(change.documentId, change);\r\n            });\r\n\r\n\r\n            ret.error = categorized.errors;\r\n\r\n            /**\r\n             * Reset the event bulk because\r\n             * conflicts can still appear after the categorization\r\n             */\r\n            const eventBulk = categorized.eventBulk;\r\n            eventBulk.events = [];\r\n\r\n            await Promise.all([\r\n                /**\r\n                 * Inserts\r\n                 * @link https://sparkbyexamples.com/mongodb/mongodb-insert-if-not-exists/\r\n                 */\r\n                Promise.all(\r\n                    categorized.bulkInsertDocs.map(async (writeRow) => {\r\n                        const docId: string = writeRow.document[primaryPath] as any;\r\n                        const writeResult = await mongoCollection.findOneAndUpdate(\r\n                            {\r\n                                [this.inMongoPrimaryPath]: docId\r\n                            },\r\n                            {\r\n                                $setOnInsert: swapRxDocToMongo(writeRow.document)\r\n                            },\r\n                            {\r\n                                upsert: true,\r\n                                includeResultMetadata: true\r\n                            }\r\n                        );\r\n                        if (writeResult.value) {\r\n                            // had insert conflict\r\n                            const conflictError: RxStorageWriteErrorConflict<RxDocType> = {\r\n                                status: 409,\r\n                                documentId: docId,\r\n                                writeRow,\r\n                                documentInDb: swapMongoToRxDoc(ensureNotFalsy(writeResult.value)),\r\n                                isError: true\r\n                            };\r\n                            ret.error.push(conflictError);\r\n                        } else {\r\n                            const event = changeByDocId.get(docId);\r\n                            if (event) {\r\n                                eventBulk.events.push(event);\r\n                            }\r\n                        }\r\n                    })\r\n                ),\r\n                /**\r\n                 * Updates\r\n                 */\r\n                Promise.all(\r\n                    categorized.bulkUpdateDocs.map(async (writeRow) => {\r\n                        const docId = writeRow.document[primaryPath] as string;\r\n                        const writeResult = await mongoCollection.findOneAndReplace(\r\n                            {\r\n                                [this.inMongoPrimaryPath]: docId,\r\n                                _rev: ensureNotFalsy(writeRow.previous)._rev\r\n                            },\r\n                            swapRxDocToMongo(writeRow.document),\r\n                            {\r\n                                includeResultMetadata: true,\r\n                                upsert: false,\r\n                                returnDocument: 'before'\r\n                            }\r\n                        );\r\n                        if (!writeResult.ok) {\r\n                            const currentDocState = await this.findDocumentsById([docId], true);\r\n                            const currentDoc = currentDocState[0];\r\n                            // had insert conflict\r\n                            const conflictError: RxStorageWriteErrorConflict<RxDocType> = {\r\n                                status: 409,\r\n                                documentId: docId,\r\n                                writeRow,\r\n                                documentInDb: ensureNotFalsy(currentDoc),\r\n                                isError: true\r\n                            };\r\n                            ret.error.push(conflictError);\r\n                        } else {\r\n                            const event = getFromMapOrThrow(changeByDocId, docId);\r\n                            eventBulk.events.push(event);\r\n                        }\r\n\r\n                    })\r\n                )\r\n            ]);\r\n\r\n            if (categorized.eventBulk.events.length > 0) {\r\n                const lastState = ensureNotFalsy(categorized.newestRow).document;\r\n                categorized.eventBulk.checkpoint = {\r\n                    id: lastState[primaryPath],\r\n                    lwt: lastState._meta.lwt\r\n                };\r\n                categorized.eventBulk.endTime = now();\r\n                this.changes$.next(categorized.eventBulk);\r\n            }\r\n\r\n            this.runningOperations.next(this.runningOperations.getValue() - 1);\r\n            return ret;\r\n        });\r\n        return this.writeQueue;\r\n\r\n    }\r\n\r\n    async findDocumentsById(\r\n        docIds: string[],\r\n        withDeleted: boolean,\r\n        session?: ClientSession\r\n    ): Promise<RxDocumentData<RxDocType>[]> {\r\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\r\n        const mongoCollection = await this.mongoCollectionPromise;\r\n        const primaryPath = this.primaryPath;\r\n\r\n        const plainQuery: MongoQuerySelector<any> = {\r\n            [primaryPath]: {\r\n                $in: docIds\r\n            }\r\n        };\r\n        if (!withDeleted) {\r\n            plainQuery._deleted = false;\r\n        }\r\n        const result: RxDocumentData<RxDocType>[] = [];\r\n        const queryResult = await mongoCollection.find(\r\n            plainQuery,\r\n            {\r\n                session\r\n            }\r\n        ).toArray();\r\n        queryResult.forEach(row => {\r\n            result.push(\r\n                swapMongoToRxDoc(\r\n                    row as any\r\n                )\r\n            );\r\n        });\r\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\r\n        return result;\r\n    }\r\n\r\n    async query(\r\n        originalPreparedQuery: PreparedQuery<RxDocType>\r\n    ): Promise<RxStorageQueryResult<RxDocType>> {\r\n        const preparedQuery = prepareMongoDBQuery(this.schema, originalPreparedQuery.query);\r\n\r\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\r\n        await this.writeQueue;\r\n        const mongoCollection = await this.mongoCollectionPromise;\r\n\r\n        let query = mongoCollection.find(preparedQuery.mongoSelector);\r\n        if (preparedQuery.query.skip) {\r\n            query = query.skip(preparedQuery.query.skip);\r\n        }\r\n        if (preparedQuery.query.limit) {\r\n            query = query.limit(preparedQuery.query.limit);\r\n        }\r\n        if (preparedQuery.query.sort) {\r\n            query = query.sort(preparedQuery.mongoSort);\r\n        }\r\n        const resultDocs = await query.toArray();\r\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\r\n        return {\r\n            documents: resultDocs.map(d => swapMongoToRxDoc(d))\r\n        };\r\n    }\r\n\r\n    async count(\r\n        originalPreparedQuery: PreparedQuery<RxDocType>\r\n    ): Promise<RxStorageCountResult> {\r\n        const preparedQuery = prepareMongoDBQuery(this.schema, originalPreparedQuery.query);\r\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\r\n        await this.writeQueue;\r\n        const mongoCollection = await this.mongoCollectionPromise;\r\n        const count = await mongoCollection.countDocuments(preparedQuery.mongoSelector);\r\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\r\n        return {\r\n            count,\r\n            mode: 'fast'\r\n        };\r\n    }\r\n\r\n    async cleanup(minimumDeletedTime: number): Promise<boolean> {\r\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\r\n        const mongoCollection = await this.mongoCollectionPromise;\r\n        const maxDeletionTime = now() - minimumDeletedTime;\r\n        await mongoCollection.deleteMany({\r\n            _deleted: true,\r\n            '_meta.lwt': {\r\n                $lt: maxDeletionTime\r\n            }\r\n        });\r\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\r\n        return true;\r\n    }\r\n\r\n    async getAttachmentData(\r\n        _documentId: string,\r\n        _attachmentId: string,\r\n        _digest: string\r\n    ): Promise<string> {\r\n        await this.mongoCollectionPromise;\r\n        throw new Error('attachments not implemented, make a PR');\r\n    }\r\n\r\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\r\n        return this.changes$;\r\n    }\r\n\r\n    async remove(): Promise<void> {\r\n        if (this.closed) {\r\n            throw new Error('already closed');\r\n        }\r\n        this.runningOperations.next(this.runningOperations.getValue() + 1);\r\n        const mongoCollection = await this.mongoCollectionPromise;\r\n        await mongoCollection.drop();\r\n        this.runningOperations.next(this.runningOperations.getValue() - 1);\r\n        await this.close();\r\n    }\r\n\r\n    async close(): Promise<void> {\r\n        // TODO without this next-tick we have random fails in the tests\r\n        await requestIdlePromise(200);\r\n\r\n        if (this.closed) {\r\n            return this.closed;\r\n        }\r\n        this.closed = (async () => {\r\n            await this.mongoCollectionPromise;\r\n            await firstValueFrom(this.runningOperations.pipe(filter(c => c === 0)));\r\n            // await ensureNotFalsy(this.mongoChangeStream).close();\r\n            await this.mongoClient.close();\r\n        })();\r\n        return this.closed;\r\n    }\r\n\r\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\r\n        return new Subject();\r\n    }\r\n    async resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> { }\r\n}\r\n\r\nexport function createMongoDBStorageInstance<RxDocType>(\r\n    storage: RxStorageMongoDB,\r\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMongoDBInstanceCreationOptions>,\r\n    settings: RxStorageMongoDBSettings\r\n): Promise<RxStorageInstanceMongoDB<RxDocType>> {\r\n    const instance = new RxStorageInstanceMongoDB(\r\n        storage,\r\n        params.databaseName,\r\n        params.collectionName,\r\n        params.schema,\r\n        {},\r\n        params.options,\r\n        settings\r\n    );\r\n    return Promise.resolve(instance);\r\n}\r\n"],"mappings":"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","ignoreList":[]}