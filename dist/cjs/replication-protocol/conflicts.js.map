{"version":3,"file":"conflicts.js","names":["_index","require","_rxStorageHelper","defaultConflictHandler","i","_context","newDocumentState","stripAttachmentsDataFromDocument","realMasterState","deepEqual","Promise","resolve","isEqual","documentData","exports","resolveConflictError","state","input","forkState","conflictHandler","conflictHandlerOutput","undefined","resolvedDoc","Object","assign","_meta","flatClone","_rev","getDefaultRevision","_attachments","lwt","now","createRevision","checkpointKey","output"],"sources":["../../../src/replication-protocol/conflicts.ts"],"sourcesContent":["import type {\r\n    RxConflictHandler,\r\n    RxConflictHandlerInput,\r\n    RxConflictHandlerOutput,\r\n    RxDocumentData,\r\n    RxStorageInstanceReplicationState\r\n} from '../types/index.d.ts';\r\nimport {\r\n    getDefaultRevision,\r\n    createRevision,\r\n    now,\r\n    flatClone,\r\n    deepEqual\r\n} from '../plugins/utils/index.ts';\r\nimport { stripAttachmentsDataFromDocument } from '../rx-storage-helper.ts';\r\n\r\nexport const defaultConflictHandler: RxConflictHandler<any> = function (\r\n    i: RxConflictHandlerInput<any>,\r\n    _context: string\r\n): Promise<RxConflictHandlerOutput<any>> {\r\n    const newDocumentState = stripAttachmentsDataFromDocument(i.newDocumentState);\r\n    const realMasterState = stripAttachmentsDataFromDocument(i.realMasterState);\r\n\r\n    /**\r\n     * If the documents are deep equal,\r\n     * we have no conflict.\r\n     * On your custom conflict handler you might only\r\n     * check some properties, like the updatedAt time,\r\n     * for better performance, because deepEqual is expensive.\r\n     */\r\n    if (deepEqual(\r\n        newDocumentState,\r\n        realMasterState\r\n    )) {\r\n        return Promise.resolve({\r\n            isEqual: true\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The default conflict handler will always\r\n     * drop the fork state and use the master state instead.\r\n     */\r\n    return Promise.resolve({\r\n        isEqual: false,\r\n        documentData: i.realMasterState\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * Resolves a conflict error or determines that the given document states are equal.\r\n * Returns the resolved document that must be written to the fork.\r\n * Then the new document state can be pushed upstream.\r\n * If document is not in conflict, returns undefined.\r\n * If error is non-409, it throws an error.\r\n * Conflicts are only solved in the upstream, never in the downstream.\r\n */\r\nexport async function resolveConflictError<RxDocType>(\r\n    state: RxStorageInstanceReplicationState<RxDocType>,\r\n    input: RxConflictHandlerInput<RxDocType>,\r\n    forkState: RxDocumentData<RxDocType>\r\n): Promise<{\r\n    resolvedDoc: RxDocumentData<RxDocType>;\r\n    output: RxConflictHandlerOutput<RxDocType>;\r\n} | undefined> {\r\n    const conflictHandler: RxConflictHandler<RxDocType> = state.input.conflictHandler;\r\n    const conflictHandlerOutput = await conflictHandler(input, 'replication-resolve-conflict');\r\n\r\n    if (conflictHandlerOutput.isEqual) {\r\n        /**\r\n         * Documents are equal,\r\n         * so this is not a conflict -> do nothing.\r\n         */\r\n        return undefined;\r\n    } else {\r\n        /**\r\n         * We have a resolved conflict,\r\n         * use the resolved document data.\r\n         */\r\n        const resolvedDoc: RxDocumentData<RxDocType> = Object.assign(\r\n            {},\r\n            conflictHandlerOutput.documentData,\r\n            {\r\n                /**\r\n                 * Because the resolved conflict is written to the fork,\r\n                 * we have to keep/update the forks _meta data, not the masters.\r\n                 */\r\n                _meta: flatClone(forkState._meta),\r\n                _rev: getDefaultRevision(),\r\n                _attachments: flatClone(forkState._attachments)\r\n            }\r\n        ) as any;\r\n        resolvedDoc._meta.lwt = now();\r\n        resolvedDoc._rev = createRevision(\r\n            await state.checkpointKey,\r\n            forkState\r\n        );\r\n        return {\r\n            resolvedDoc,\r\n            output: conflictHandlerOutput\r\n        };\r\n    }\r\n}\r\n"],"mappings":";;;;;;;AAOA,IAAAA,MAAA,GAAAC,OAAA;AAOA,IAAAC,gBAAA,GAAAD,OAAA;AAEO,IAAME,sBAA8C,GAAG,SAAAA,CAC1DC,CAA8B,EAC9BC,QAAgB,EACqB;EACrC,IAAMC,gBAAgB,GAAG,IAAAC,iDAAgC,EAACH,CAAC,CAACE,gBAAgB,CAAC;EAC7E,IAAME,eAAe,GAAG,IAAAD,iDAAgC,EAACH,CAAC,CAACI,eAAe,CAAC;;EAE3E;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,IAAAC,gBAAS,EACTH,gBAAgB,EAChBE,eACJ,CAAC,EAAE;IACC,OAAOE,OAAO,CAACC,OAAO,CAAC;MACnBC,OAAO,EAAE;IACb,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;EACI,OAAOF,OAAO,CAACC,OAAO,CAAC;IACnBC,OAAO,EAAE,KAAK;IACdC,YAAY,EAAET,CAAC,CAACI;EACpB,CAAC,CAAC;AACN,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPAM,OAAA,CAAAX,sBAAA,GAAAA,sBAAA;AAQO,eAAeY,oBAAoBA,CACtCC,KAAmD,EACnDC,KAAwC,EACxCC,SAAoC,EAIzB;EACX,IAAMC,eAA6C,GAAGH,KAAK,CAACC,KAAK,CAACE,eAAe;EACjF,IAAMC,qBAAqB,GAAG,MAAMD,eAAe,CAACF,KAAK,EAAE,8BAA8B,CAAC;EAE1F,IAAIG,qBAAqB,CAACR,OAAO,EAAE;IAC/B;AACR;AACA;AACA;IACQ,OAAOS,SAAS;EACpB,CAAC,MAAM;IACH;AACR;AACA;AACA;IACQ,IAAMC,WAAsC,GAAGC,MAAM,CAACC,MAAM,CACxD,CAAC,CAAC,EACFJ,qBAAqB,CAACP,YAAY,EAClC;MACI;AAChB;AACA;AACA;MACgBY,KAAK,EAAE,IAAAC,gBAAS,EAACR,SAAS,CAACO,KAAK,CAAC;MACjCE,IAAI,EAAE,IAAAC,yBAAkB,EAAC,CAAC;MAC1BC,YAAY,EAAE,IAAAH,gBAAS,EAACR,SAAS,CAACW,YAAY;IAClD,CACJ,CAAQ;IACRP,WAAW,CAACG,KAAK,CAACK,GAAG,GAAG,IAAAC,UAAG,EAAC,CAAC;IAC7BT,WAAW,CAACK,IAAI,GAAG,IAAAK,qBAAc,EAC7B,MAAMhB,KAAK,CAACiB,aAAa,EACzBf,SACJ,CAAC;IACD,OAAO;MACHI,WAAW;MACXY,MAAM,EAAEd;IACZ,CAAC;EACL;AACJ","ignoreList":[]}