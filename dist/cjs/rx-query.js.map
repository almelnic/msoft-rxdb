{"version":3,"file":"rx-query.js","names":["_rxjs","require","_operators","_index","_rxError","_hooks","_eventReduce","_queryCache","_rxQueryHelper","_rxQuerySingleResult","_queryPlanner","_queryCount","newQueryID","RxQueryBase","exports","op","mangoQuery","collection","other","id","_execOverDatabaseCount","_creationTime","now","_lastEnsureEqual","uncached","refCount$","BehaviorSubject","_result","_latestChangeEvent","_lastExecStart","_lastExecEnd","_ensureEqualQueue","PROMISE_RESOLVE_FALSE","_getDefaultQuery","isFindOneByIdQuery","schema","primaryPath","_proto","prototype","_setResultData","newResultData","newRxError","database","name","RxQuerySingleResult","Map","Array","from","values","newQueryResult","length","_execOverDatabase","preparedQuery","getPreparedQuery","result","storageInstance","count","mode","allowSlowCount","queryObj","ids","ensureNotFalsy","selector","$in","ret","mustBeQueried","forEach","docData","_docCache","getLatestDocumentDataIfExists","_deleted","doc","getCachedRxDocument","set","push","docs","findDocumentsById","primary","docsPromise","queryCollection","then","exec","throwIfMissing","query","_ensureEqual","useResult","getValue","toString","stringObj","sortObject","value","JSON","stringify","hookInput","rxQuery","normalizeMangoQuery","jsonSchema","$eq","index","unshift","runPluginHooks","prepareQuery","doesDocumentDataMatch","queryMatcher","remove","isArray","Promise","all","map","incrementalRemove","runQueryUpdateFunction","asRxQuery","update","_updateObj","pluginMissing","patch","incrementalPatch","modify","mutationFunction","incrementalModify","where","_queryObj","sort","_params","skip","_amount","limit","_createClass2","default","key","get","_$","results$","$","pipe","filter","changeEvent","isLocal","startWith","mergeMap","shareReplay","RXJS_SHARE_REPLAY_DEFAULTS","distinctUntilChanged","prev","curr","time","merge","reactivity","getReactivityFactory","fromObservable","undefined","normalizedQuery","overwriteGetterForCaching","getQueryMatcher","tunnelQueryCache","getByQuery","createRxQuery","triggerCacheReplacement","_isResultsInSync","currentLatestEventNumber","_changeEventBuffer","getCounter","awaitBeforeReads","size","fn","destroyed","__ensureEqual","mustReExec","missedChangeEvents","getFrom","runChangeEvents","reduceByLastOfDoc","previousCount","newCount","cE","didMatchBefore","previousDocumentData","doesMatchNow","documentData","eventReduceResult","calculateNewResults","runFullQueryAgain","changed","newResults","areRxDocumentArraysEqual","docsData","resolve","mutateableQuery","queryPlan","getQueryPlan","docIds","docId","docsFromStorage","appendToArray","fromStorageList","queryResult","documents","Object","keys","find","r","isRxQuery","obj"],"sources":["../../src/rx-query.ts"],"sourcesContent":["import {\r\n    BehaviorSubject,\r\n    Observable,\r\n    merge\r\n} from 'rxjs';\r\nimport {\r\n    mergeMap,\r\n    filter,\r\n    map,\r\n    startWith,\r\n    distinctUntilChanged,\r\n    shareReplay\r\n} from 'rxjs/operators';\r\nimport {\r\n    sortObject,\r\n    pluginMissing,\r\n    overwriteGetterForCaching,\r\n    now,\r\n    PROMISE_RESOLVE_FALSE,\r\n    RXJS_SHARE_REPLAY_DEFAULTS,\r\n    ensureNotFalsy,\r\n    areRxDocumentArraysEqual,\r\n    appendToArray\r\n} from './plugins/utils/index.ts';\r\nimport {\r\n    newRxError\r\n} from './rx-error.ts';\r\nimport {\r\n    runPluginHooks\r\n} from './hooks.ts';\r\nimport type {\r\n    RxCollection,\r\n    RxDocument,\r\n    RxQueryOP,\r\n    RxQuery,\r\n    MangoQuery,\r\n    MangoQuerySortPart,\r\n    MangoQuerySelector,\r\n    PreparedQuery,\r\n    RxChangeEvent,\r\n    RxDocumentWriteData,\r\n    RxDocumentData,\r\n    QueryMatcher,\r\n    RxJsonSchema,\r\n    FilledMangoQuery,\r\n    ModifyFunction\r\n} from './types/index.d.ts';\r\nimport { calculateNewResults } from './event-reduce.ts';\r\nimport { triggerCacheReplacement } from './query-cache.ts';\r\nimport {\r\n    getQueryMatcher,\r\n    normalizeMangoQuery,\r\n    runQueryUpdateFunction\r\n\r\n} from './rx-query-helper.ts';\r\nimport { RxQuerySingleResult } from './rx-query-single-result.ts';\r\nimport { getQueryPlan } from './query-planner.ts';\r\n\r\nlet _queryCount = 0;\r\nconst newQueryID = function (): number {\r\n    return ++_queryCount;\r\n};\r\n\r\nexport class RxQueryBase<\r\n    RxDocType,\r\n    RxQueryResult,\r\n    OrmMethods = {},\r\n    Reactivity = unknown,\r\n> {\r\n\r\n    public id: number = newQueryID();\r\n\r\n    /**\r\n     * Some stats then are used for debugging and cache replacement policies\r\n     */\r\n    public _execOverDatabaseCount: number = 0;\r\n    public _creationTime = now();\r\n\r\n    // used in the query-cache to determine if the RxQuery can be cleaned up.\r\n    public _lastEnsureEqual = 0;\r\n\r\n    public uncached = false;\r\n\r\n    // used to count the subscribers to the query\r\n    public refCount$ = new BehaviorSubject(null);\r\n\r\n    public isFindOneByIdQuery: false | string | string[];\r\n\r\n\r\n    /**\r\n     * Contains the current result state\r\n     * or null if query has not run yet.\r\n     */\r\n    public _result: RxQuerySingleResult<RxDocType> | null = null;\r\n\r\n\r\n    constructor(\r\n        public op: RxQueryOP,\r\n        public mangoQuery: Readonly<MangoQuery<RxDocType>>,\r\n        public collection: RxCollection<RxDocType>,\r\n        // used by some plugins\r\n        public other: any = {}\r\n    ) {\r\n        if (!mangoQuery) {\r\n            this.mangoQuery = _getDefaultQuery();\r\n        }\r\n\r\n        this.isFindOneByIdQuery = isFindOneByIdQuery(\r\n            this.collection.schema.primaryPath as string,\r\n            mangoQuery\r\n        );\r\n    }\r\n    get $(): Observable<RxQueryResult> {\r\n        if (!this._$) {\r\n            const results$ = this.collection.$.pipe(\r\n                /**\r\n                 * Performance shortcut.\r\n                 * Changes to local documents are not relevant for the query.\r\n                 */\r\n                filter(changeEvent => !changeEvent.isLocal),\r\n                /**\r\n                 * Start once to ensure the querying also starts\r\n                 * when there where no changes.\r\n                 */\r\n                startWith(null),\r\n                // ensure query results are up to date.\r\n                mergeMap(() => _ensureEqual(this as any)),\r\n                // use the current result set, written by _ensureEqual().\r\n                map(() => this._result),\r\n                // do not run stuff above for each new subscriber, only once.\r\n                shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\r\n                // do not proceed if result set has not changed.\r\n                distinctUntilChanged((prev, curr) => {\r\n                    if (prev && prev.time === ensureNotFalsy(curr).time) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }),\r\n                filter(result => !!result),\r\n                /**\r\n                 * Map the result set to a single RxDocument or an array,\r\n                 * depending on query type\r\n                 */\r\n                map((result) => {\r\n                    return ensureNotFalsy(result).getValue();\r\n                })\r\n            );\r\n\r\n            this._$ = merge<any>(\r\n                results$,\r\n                /**\r\n                 * Also add the refCount$ to the query observable\r\n                 * to allow us to count the amount of subscribers.\r\n                 */\r\n                this.refCount$.pipe(\r\n                    filter(() => false)\r\n                )\r\n            );\r\n        }\r\n        return this._$ as any;\r\n    }\r\n\r\n    get $$(): Reactivity {\r\n        const reactivity = this.collection.database.getReactivityFactory();\r\n        return reactivity.fromObservable(\r\n            this.$,\r\n            undefined,\r\n            this.collection.database\r\n        ) as any;\r\n    }\r\n\r\n    // stores the changeEvent-number of the last handled change-event\r\n    public _latestChangeEvent: -1 | number = -1;\r\n\r\n    // time stamps on when the last full exec over the database has run\r\n    // used to properly handle events that happen while the find-query is running\r\n    // TODO do we still need these properties?\r\n    public _lastExecStart: number = 0;\r\n    public _lastExecEnd: number = 0;\r\n\r\n    /**\r\n     * ensures that the exec-runs\r\n     * are not run in parallel\r\n     */\r\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\r\n\r\n    /**\r\n     * Returns an observable that emits the results\r\n     * This should behave like an rxjs-BehaviorSubject which means:\r\n     * - Emit the current result-set on subscribe\r\n     * - Emit the new result-set when an RxChangeEvent comes in\r\n     * - Do not emit anything before the first result-set was created (no null)\r\n     */\r\n    public _$?: Observable<RxQueryResult>;\r\n\r\n    /**\r\n     * set the new result-data as result-docs of the query\r\n     * @param newResultData json-docs that were received from the storage\r\n     */\r\n    _setResultData(newResultData: RxDocumentData<RxDocType>[] | number | Map<string, RxDocumentData<RxDocType>>): void {\r\n        if (typeof newResultData === 'undefined') {\r\n            throw newRxError('QU18', {\r\n                database: this.collection.database.name,\r\n                collection: this.collection.name\r\n            });\r\n        }\r\n        if (typeof newResultData === 'number') {\r\n            this._result = new RxQuerySingleResult<RxDocType>(\r\n                this as any,\r\n                [],\r\n                newResultData\r\n            );\r\n            return;\r\n        } else if (newResultData instanceof Map) {\r\n            newResultData = Array.from((newResultData as Map<string, RxDocumentData<RxDocType>>).values());\r\n        }\r\n\r\n        const newQueryResult = new RxQuerySingleResult<RxDocType>(\r\n            this as any,\r\n            newResultData,\r\n            newResultData.length\r\n        );\r\n        this._result = newQueryResult;\r\n    }\r\n\r\n    /**\r\n     * executes the query on the database\r\n     * @return results-array with document-data\r\n     */\r\n    async _execOverDatabase(): Promise<RxDocumentData<RxDocType>[] | number> {\r\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\r\n        this._lastExecStart = now();\r\n\r\n\r\n        if (this.op === 'count') {\r\n            const preparedQuery = this.getPreparedQuery();\r\n            const result = await this.collection.storageInstance.count(preparedQuery);\r\n            if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\r\n                throw newRxError('QU14', {\r\n                    collection: this.collection,\r\n                    queryObj: this.mangoQuery\r\n                });\r\n            } else {\r\n                return result.count;\r\n            }\r\n        }\r\n\r\n        if (this.op === 'findByIds') {\r\n            const ids: string[] = ensureNotFalsy(this.mangoQuery.selector as any)[this.collection.schema.primaryPath].$in;\r\n            const ret = new Map<string, RxDocument<RxDocType>>();\r\n            const mustBeQueried: string[] = [];\r\n            // first try to fill from docCache\r\n            ids.forEach(id => {\r\n                const docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\r\n                if (docData) {\r\n                    if (!docData._deleted) {\r\n                        const doc = this.collection._docCache.getCachedRxDocument(docData);\r\n                        ret.set(id, doc);\r\n                    }\r\n                } else {\r\n                    mustBeQueried.push(id);\r\n                }\r\n            });\r\n            // everything which was not in docCache must be fetched from the storage\r\n            if (mustBeQueried.length > 0) {\r\n                const docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\r\n                docs.forEach(docData => {\r\n                    const doc = this.collection._docCache.getCachedRxDocument(docData);\r\n                    ret.set(doc.primary, doc);\r\n                });\r\n            }\r\n            return ret as any;\r\n        }\r\n\r\n\r\n        const docsPromise = queryCollection<RxDocType>(this as any);\r\n        return docsPromise.then(docs => {\r\n            this._lastExecEnd = now();\r\n            return docs;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Execute the query\r\n     * To have an easier implementations,\r\n     * just subscribe and use the first result\r\n     */\r\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\r\n    public exec(): Promise<RxQueryResult>;\r\n    public async exec(throwIfMissing?: boolean): Promise<any> {\r\n        if (throwIfMissing && this.op !== 'findOne') {\r\n            throw newRxError('QU9', {\r\n                collection: this.collection.name,\r\n                query: this.mangoQuery,\r\n                op: this.op\r\n            });\r\n        }\r\n\r\n        /**\r\n         * run _ensureEqual() here,\r\n         * this will make sure that errors in the query which throw inside of the RxStorage,\r\n         * will be thrown at this execution context and not in the background.\r\n         */\r\n        await _ensureEqual(this as any);\r\n        const useResult = ensureNotFalsy(this._result);\r\n        return useResult.getValue(throwIfMissing);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * cached call to get the queryMatcher\r\n     * @overwrites itself with the actual value\r\n     */\r\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocType>> {\r\n        const schema = this.collection.schema.jsonSchema;\r\n        const normalizedQuery = normalizeMangoQuery(\r\n            this.collection.schema.jsonSchema,\r\n            this.mangoQuery\r\n        );\r\n        return overwriteGetterForCaching(\r\n            this,\r\n            'queryMatcher',\r\n            getQueryMatcher(\r\n                schema,\r\n                normalizedQuery\r\n            ) as any\r\n        );\r\n    }\r\n\r\n    /**\r\n     * returns a string that is used for equal-comparisons\r\n     * @overwrites itself with the actual value\r\n     */\r\n    toString(): string {\r\n        const stringObj = sortObject({\r\n            op: this.op,\r\n            query: this.mangoQuery,\r\n            other: this.other\r\n        }, true);\r\n        const value = JSON.stringify(stringObj);\r\n        this.toString = () => value;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * returns the prepared query\r\n     * which can be send to the storage instance to query for documents.\r\n     * @overwrites itself with the actual value.\r\n     */\r\n    getPreparedQuery(): PreparedQuery<RxDocType> {\r\n        const hookInput = {\r\n            rxQuery: this,\r\n            // can be mutated by the hooks so we have to deep clone first.\r\n            mangoQuery: normalizeMangoQuery<RxDocType>(\r\n                this.collection.schema.jsonSchema,\r\n                this.mangoQuery\r\n            )\r\n        };\r\n        (hookInput.mangoQuery.selector as any)._deleted = { $eq: false };\r\n        if (hookInput.mangoQuery.index) {\r\n            hookInput.mangoQuery.index.unshift('_deleted');\r\n        }\r\n        runPluginHooks('prePrepareQuery', hookInput);\r\n\r\n        const value = prepareQuery(\r\n            this.collection.schema.jsonSchema,\r\n            hookInput.mangoQuery as any\r\n        );\r\n\r\n        this.getPreparedQuery = () => value;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * returns true if the document matches the query,\r\n     * does not use the 'skip' and 'limit'\r\n     */\r\n    doesDocumentDataMatch(docData: RxDocType | any): boolean {\r\n        // if doc is deleted, it cannot match\r\n        if (docData._deleted) {\r\n            return false;\r\n        }\r\n\r\n        return this.queryMatcher(docData);\r\n    }\r\n\r\n    /**\r\n     * deletes all found documents\r\n     * @return promise with deleted documents\r\n     */\r\n    remove(): Promise<RxQueryResult> {\r\n        return this\r\n            .exec()\r\n            .then(docs => {\r\n                if (Array.isArray(docs)) {\r\n                    // TODO use a bulk operation instead of running .remove() on each document\r\n                    return Promise.all(docs.map(doc => doc.remove()));\r\n                } else {\r\n                    return (docs as any).remove();\r\n                }\r\n            });\r\n    }\r\n    incrementalRemove(): Promise<RxQueryResult> {\r\n        return runQueryUpdateFunction(\r\n            this.asRxQuery,\r\n            (doc) => doc.incrementalRemove(),\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * helper function to transform RxQueryBase to RxQuery type\r\n     */\r\n    get asRxQuery(): RxQuery<RxDocType, RxQueryResult> {\r\n        return this as any;\r\n    }\r\n\r\n    /**\r\n     * updates all found documents\r\n     * @overwritten by plugin (optional)\r\n     */\r\n    update(_updateObj: any): Promise<RxQueryResult> {\r\n        throw pluginMissing('update');\r\n    }\r\n\r\n    patch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\r\n        return runQueryUpdateFunction(\r\n            this.asRxQuery,\r\n            (doc) => doc.patch(patch),\r\n        );\r\n    }\r\n    incrementalPatch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\r\n        return runQueryUpdateFunction(\r\n            this.asRxQuery,\r\n            (doc) => doc.incrementalPatch(patch),\r\n        );\r\n    }\r\n    modify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\r\n        return runQueryUpdateFunction(\r\n            this.asRxQuery,\r\n            (doc) => doc.modify(mutationFunction),\r\n        );\r\n    }\r\n    incrementalModify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\r\n        return runQueryUpdateFunction(\r\n            this.asRxQuery,\r\n            (doc) => doc.incrementalModify(mutationFunction),\r\n        );\r\n    }\r\n\r\n\r\n    // we only set some methods of query-builder here\r\n    // because the others depend on these ones\r\n    where(_queryObj: MangoQuerySelector<RxDocType> | keyof RxDocType | string): RxQuery<RxDocType, RxQueryResult> {\r\n        throw pluginMissing('query-builder');\r\n    }\r\n    sort(_params: string | MangoQuerySortPart<RxDocType>): RxQuery<RxDocType, RxQueryResult> {\r\n        throw pluginMissing('query-builder');\r\n    }\r\n    skip(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\r\n        throw pluginMissing('query-builder');\r\n    }\r\n    limit(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\r\n        throw pluginMissing('query-builder');\r\n    }\r\n}\r\n\r\n\r\nexport function _getDefaultQuery<RxDocType>(): MangoQuery<RxDocType> {\r\n    return {\r\n        selector: {}\r\n    };\r\n}\r\n\r\n/**\r\n * run this query through the QueryCache\r\n */\r\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\r\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\r\n): RxQuery<RxDocumentType, RxQueryResult> {\r\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\r\n}\r\n\r\nexport function createRxQuery<RxDocType>(\r\n    op: RxQueryOP,\r\n    queryObj: MangoQuery<RxDocType>,\r\n    collection: RxCollection<RxDocType>,\r\n    other?: any\r\n) {\r\n    runPluginHooks('preCreateRxQuery', {\r\n        op,\r\n        queryObj,\r\n        collection,\r\n        other\r\n    });\r\n\r\n    let ret = new RxQueryBase<RxDocType, any>(op, queryObj, collection, other);\r\n\r\n    // ensure when created with same params, only one is created\r\n    ret = tunnelQueryCache(ret);\r\n    triggerCacheReplacement(collection);\r\n\r\n    return ret;\r\n}\r\n\r\n/**\r\n * Check if the current results-state is in sync with the database\r\n * which means that no write event happened since the last run.\r\n * @return false if not which means it should re-execute\r\n */\r\nfunction _isResultsInSync(rxQuery: RxQueryBase<any, any>): boolean {\r\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\r\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * wraps __ensureEqual()\r\n * to ensure it does not run in parallel\r\n * @return true if has changed, false if not\r\n */\r\nasync function _ensureEqual(rxQuery: RxQueryBase<any, any>): Promise<boolean> {\r\n    if (rxQuery.collection.awaitBeforeReads.size > 0) {\r\n        await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));\r\n    }\r\n\r\n    // Optimisation shortcut\r\n    if (\r\n        rxQuery.collection.database.destroyed ||\r\n        _isResultsInSync(rxQuery)\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\r\n        .then(() => __ensureEqual(rxQuery));\r\n    return rxQuery._ensureEqualQueue;\r\n}\r\n\r\n/**\r\n * ensures that the results of this query is equal to the results which a query over the database would give\r\n * @return true if results have changed\r\n */\r\nfunction __ensureEqual<RxDocType>(rxQuery: RxQueryBase<RxDocType, any>): Promise<boolean> {\r\n    rxQuery._lastEnsureEqual = now();\r\n\r\n    /**\r\n     * Optimisation shortcuts\r\n     */\r\n    if (\r\n        // db is closed\r\n        rxQuery.collection.database.destroyed ||\r\n        // nothing happened since last run\r\n        _isResultsInSync(rxQuery)\r\n    ) {\r\n        return PROMISE_RESOLVE_FALSE;\r\n    }\r\n\r\n    let ret = false;\r\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\r\n    if (rxQuery._latestChangeEvent === -1) {\r\n        // have not executed yet -> must run\r\n        mustReExec = true;\r\n    }\r\n\r\n    /**\r\n     * try to use EventReduce to calculate the new results\r\n     */\r\n    if (!mustReExec) {\r\n        const missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\r\n        if (missedChangeEvents === null) {\r\n            // changeEventBuffer is of bounds -> we must re-execute over the database\r\n            mustReExec = true;\r\n        } else {\r\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\r\n\r\n            const runChangeEvents: RxChangeEvent<RxDocType>[] = rxQuery.asRxQuery.collection\r\n                ._changeEventBuffer\r\n                .reduceByLastOfDoc(missedChangeEvents);\r\n\r\n            if (rxQuery.op === 'count') {\r\n                // 'count' query\r\n                const previousCount = ensureNotFalsy(rxQuery._result).count;\r\n                let newCount = previousCount;\r\n                runChangeEvents.forEach(cE => {\r\n                    const didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\r\n                    const doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\r\n\r\n                    if (!didMatchBefore && doesMatchNow) {\r\n                        newCount++;\r\n                    }\r\n                    if (didMatchBefore && !doesMatchNow) {\r\n                        newCount--;\r\n                    }\r\n                });\r\n                if (newCount !== previousCount) {\r\n                    ret = true; // true because results changed\r\n                    rxQuery._setResultData(newCount as any);\r\n                }\r\n            } else {\r\n                // 'find' or 'findOne' query\r\n                const eventReduceResult = calculateNewResults(\r\n                    rxQuery as any,\r\n                    runChangeEvents\r\n                );\r\n                if (eventReduceResult.runFullQueryAgain) {\r\n                    // could not calculate the new results, execute must be done\r\n                    mustReExec = true;\r\n                } else if (eventReduceResult.changed) {\r\n                    // we got the new results, we do not have to re-execute, mustReExec stays false\r\n                    ret = true; // true because results changed\r\n                    rxQuery._setResultData(eventReduceResult.newResults as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // oh no we have to re-execute the whole query over the database\r\n    if (mustReExec) {\r\n        return rxQuery._execOverDatabase()\r\n            .then(newResultData => {\r\n\r\n                /**\r\n                 * The RxStorage is defined to always first emit events and then return\r\n                 * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\r\n                 * has been run, not the one from before.\r\n                 */\r\n                rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();\r\n\r\n                // A count query needs a different has-changed check.\r\n                if (typeof newResultData === 'number') {\r\n                    if (\r\n                        !rxQuery._result ||\r\n                        newResultData !== rxQuery._result.count\r\n                    ) {\r\n                        ret = true;\r\n                        rxQuery._setResultData(newResultData as any);\r\n                    }\r\n                    return ret;\r\n                }\r\n                if (\r\n                    !rxQuery._result ||\r\n                    !areRxDocumentArraysEqual(\r\n                        rxQuery.collection.schema.primaryPath,\r\n                        newResultData,\r\n                        rxQuery._result.docsData\r\n                    )\r\n                ) {\r\n                    ret = true; // true because results changed\r\n                    rxQuery._setResultData(newResultData as any);\r\n                }\r\n                return ret;\r\n            });\r\n    }\r\n    return Promise.resolve(ret); // true if results have changed\r\n}\r\n\r\n/**\r\n * @returns a format of the query that can be used with the storage\r\n * when calling RxStorageInstance().query()\r\n */\r\nexport function prepareQuery<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    mutateableQuery: FilledMangoQuery<RxDocType>\r\n): PreparedQuery<RxDocType> {\r\n    if (!mutateableQuery.sort) {\r\n        throw newRxError('SNH', {\r\n            query: mutateableQuery\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Store the query plan together with the\r\n     * prepared query to save performance.\r\n     */\r\n    const queryPlan = getQueryPlan(\r\n        schema,\r\n        mutateableQuery\r\n    );\r\n\r\n    return {\r\n        query: mutateableQuery,\r\n        queryPlan\r\n    };\r\n}\r\n\r\n/**\r\n * Runs the query over the storage instance\r\n * of the collection.\r\n * Does some optimizations to ensure findById is used\r\n * when specific queries are used.\r\n */\r\nexport async function queryCollection<RxDocType>(\r\n    rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType, any>\r\n): Promise<RxDocumentData<RxDocType>[]> {\r\n    let docs: RxDocumentData<RxDocType>[] = [];\r\n    const collection = rxQuery.collection;\r\n\r\n    /**\r\n     * Optimizations shortcut.\r\n     * If query is find-one-document-by-id,\r\n     * then we do not have to use the slow query() method\r\n     * but instead can use findDocumentsById()\r\n     */\r\n    if (rxQuery.isFindOneByIdQuery) {\r\n        if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\r\n            let docIds = rxQuery.isFindOneByIdQuery;\r\n            docIds = docIds.filter(docId => {\r\n                // first try to fill from docCache\r\n                const docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\r\n                if (docData) {\r\n                    if (!docData._deleted) {\r\n                        docs.push(docData);\r\n                    }\r\n                    return false;\r\n                } else {\r\n                    return true;\r\n                }\r\n            });\r\n            // otherwise get from storage\r\n            if (docIds.length > 0) {\r\n                const docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\r\n                appendToArray(docs, docsFromStorage);\r\n            }\r\n        } else {\r\n            const docId = rxQuery.isFindOneByIdQuery;\r\n\r\n            // first try to fill from docCache\r\n            let docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\r\n            if (!docData) {\r\n                // otherwise get from storage\r\n                const fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\r\n                if (fromStorageList[0]) {\r\n                    docData = fromStorageList[0];\r\n                }\r\n            }\r\n            if (docData && !docData._deleted) {\r\n                docs.push(docData);\r\n            }\r\n        }\r\n    } else {\r\n        const preparedQuery = rxQuery.getPreparedQuery();\r\n        const queryResult = await collection.storageInstance.query(preparedQuery);\r\n        docs = queryResult.documents;\r\n    }\r\n    return docs;\r\n\r\n}\r\n\r\n/**\r\n * Returns true if the given query\r\n * selects exactly one document by its id.\r\n * Used to optimize performance because these kind of\r\n * queries do not have to run over an index and can use get-by-id instead.\r\n * Returns false if no query of that kind.\r\n * Returns the document id otherwise.\r\n */\r\nexport function isFindOneByIdQuery(\r\n    primaryPath: string,\r\n    query: MangoQuery<any>\r\n): false | string | string[] {\r\n    // must have exactly one operator which must be $eq || $in\r\n    if (\r\n        !query.skip &&\r\n        query.selector &&\r\n        Object.keys(query.selector).length === 1 &&\r\n        query.selector[primaryPath]\r\n    ) {\r\n        const value: any = query.selector[primaryPath];\r\n        if (typeof value === 'string') {\r\n            return value;\r\n        } else if (\r\n            Object.keys(value).length === 1 &&\r\n            typeof value.$eq === 'string'\r\n        ) {\r\n            return value.$eq;\r\n        }\r\n\r\n        // same with $in string arrays\r\n        if (\r\n            Object.keys(value).length === 1 &&\r\n            Array.isArray(value.$eq) &&\r\n            // must only contain strings\r\n            !(value.$eq as any[]).find(r => typeof r !== 'string')\r\n        ) {\r\n            return value.$eq;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\n\r\nexport function isRxQuery(obj: any): boolean {\r\n    return obj instanceof RxQueryBase;\r\n}\r\n"],"mappings":"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","ignoreList":[]}