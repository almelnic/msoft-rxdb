{"version":3,"file":"index.js","names":["newRxError","clone","deepEqual","ensureNotFalsy","getProperty","now","objectPathMonad","setProperty","toArray","getQueryMatcher","overwritable","mingoUpdater","updateCRDT","entry","deepFreezeWhenDevMode","jsonSchema","collection","schema","crdt","queryObj","crdtOptions","storageToken","database","incrementalModify","docData","crdtDocField","field","operation","body","creator","time","lastAr","operations","push","hash","hashCRDTOperations","hashFunction","runOperationOnDocument","RX_CRDT_CONTEXT","insertCRDT","Array","isArray","insertData","result","insert","catch","err","code","doc","findOne","parameters","id","exec","sortOperationComparator","a","b","entryParts","forEach","entryPart","isMatching","selector","query","sort","skip","matcher","ifMatch","ifNotMatch","crdts","hashObj","map","op","JSON","stringify","getCRDTSchemaPart","operationSchema","type","properties","items","additionalProperties","minItems","minimum","maximum","multipleOf","required","minLength","mergeCRDTFields","crdtsA","crdtsB","length","ret","row","index","mergedOps","ids","Set","add","has","rebuildFromCRDT","base","_deleted","getCRDTConflictHandler","crdtField","getCRDTValue","conflictHandler","i","_context","newDocCrdt","newDocumentState","masterDocCrdt","realMasterState","Promise","resolve","isEqual","mergedCrdt","mergedDoc","documentData","RxDBcrdtPlugin","name","rxdb","prototypes","RxDocument","proto","oldRemove","remove","bind","$set","oldincrementalPatch","incrementalPatch","patch","oldincrementalModify","fn","context","primary","args","RxCollection","hooks","preCreateRxCollection","after","data","createRxCollection","getCrdt","isDevMode","bulkWriteBefore","storageInstance","bulkWrite","writes","all","write","newDocState","document","rebuild","docWithoutMeta","Object","entries","k","v","startsWith","recalculatedHash","bulkInsertBefore","bulkInsert","docsData","useDocsData","setMe","key","value","crdtOperations"],"sources":["../../../../src/plugins/crdt/index.ts"],"sourcesContent":["import { newRxError } from '../../rx-error.ts';\r\nimport type {\r\n    CRDTDocumentField,\r\n    CRDTEntry,\r\n    CRDTOperation,\r\n    FilledMangoQuery,\r\n    HashFunction,\r\n    JsonSchema,\r\n    RxConflictHandler,\r\n    RxConflictHandlerInput,\r\n    RxDocument,\r\n    RxDocumentData,\r\n    RxJsonSchema,\r\n    RxPlugin,\r\n    WithDeleted\r\n} from '../../types/index.d.ts';\r\nimport {\r\n    clone,\r\n    deepEqual,\r\n    ensureNotFalsy,\r\n    getProperty,\r\n    now,\r\n    objectPathMonad,\r\n    setProperty,\r\n    toArray\r\n} from '../../plugins/utils/index.ts';\r\nimport {\r\n    getQueryMatcher,\r\n    overwritable,\r\n    RxCollection,\r\n    RxDocumentWriteData,\r\n    RxError\r\n} from '../../index.ts';\r\nimport { mingoUpdater } from '../update/mingo-updater.ts';\r\n\r\n\r\n\r\nexport async function updateCRDT<RxDocType>(\r\n    this: RxDocument<RxDocType>,\r\n    entry: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]\r\n) {\r\n    entry = overwritable.deepFreezeWhenDevMode(entry) as any;\r\n\r\n    const jsonSchema = this.collection.schema.jsonSchema;\r\n    if (!jsonSchema.crdt) {\r\n        throw newRxError('CRDT1', {\r\n            schema: jsonSchema,\r\n            queryObj: entry\r\n        });\r\n    }\r\n    const crdtOptions = ensureNotFalsy(jsonSchema.crdt);\r\n    const storageToken = await this.collection.database.storageToken;\r\n\r\n    return this.incrementalModify(async (docData) => {\r\n        const crdtDocField: CRDTDocumentField<RxDocType> = clone(getProperty(docData as any, crdtOptions.field));\r\n        const operation: CRDTOperation<RxDocType> = {\r\n            body: toArray(entry),\r\n            creator: storageToken,\r\n            time: now()\r\n        };\r\n\r\n        /**\r\n         * A new write will ALWAYS be an operation in the last\r\n         * array which was non existing before.\r\n         */\r\n        const lastAr: CRDTOperation<RxDocType>[] = [operation];\r\n        crdtDocField.operations.push(lastAr);\r\n        crdtDocField.hash = await hashCRDTOperations(this.collection.database.hashFunction, crdtDocField);\r\n\r\n        docData = runOperationOnDocument(\r\n            this.collection.schema.jsonSchema,\r\n            docData,\r\n            operation\r\n        );\r\n        setProperty(docData, crdtOptions.field, crdtDocField);\r\n        return docData;\r\n    }, RX_CRDT_CONTEXT);\r\n}\r\n\r\n\r\nexport async function insertCRDT<RxDocType>(\r\n    this: RxCollection<RxDocType>,\r\n    entry: CRDTEntry<RxDocType> | CRDTEntry<RxDocType>[]\r\n) {\r\n    entry = overwritable.deepFreezeWhenDevMode(entry) as any;\r\n\r\n    const jsonSchema = this.schema.jsonSchema;\r\n    if (!jsonSchema.crdt) {\r\n        throw newRxError('CRDT1', {\r\n            schema: jsonSchema,\r\n            queryObj: entry\r\n        });\r\n    }\r\n    const crdtOptions = ensureNotFalsy(jsonSchema.crdt);\r\n    const storageToken = await this.database.storageToken;\r\n    const operation: CRDTOperation<RxDocType> = {\r\n        body: Array.isArray(entry) ? entry : [entry],\r\n        creator: storageToken,\r\n        time: now()\r\n    };\r\n\r\n    let insertData: RxDocumentWriteData<RxDocType> = {} as any;\r\n    insertData = runOperationOnDocument(\r\n        this.schema.jsonSchema,\r\n        insertData as any,\r\n        operation\r\n    ) as any;\r\n    const crdtDocField: CRDTDocumentField<RxDocType> = {\r\n        operations: [],\r\n        hash: ''\r\n    };\r\n    setProperty(insertData as any, crdtOptions.field, crdtDocField);\r\n\r\n    const lastAr: CRDTOperation<RxDocType>[] = [operation];\r\n    crdtDocField.operations.push(lastAr);\r\n    crdtDocField.hash = await hashCRDTOperations(this.database.hashFunction, crdtDocField);\r\n\r\n    const result = await this.insert(insertData).catch(async (err: RxError) => {\r\n        if (err.code === 'CONFLICT') {\r\n            // was a conflict, update document instead of inserting\r\n            const doc = await this.findOne(err.parameters.id).exec(true);\r\n            return doc.updateCRDT(entry);\r\n        } else {\r\n            throw err;\r\n        }\r\n    });\r\n    return result;\r\n}\r\n\r\n\r\nexport function sortOperationComparator<RxDocType>(a: CRDTOperation<RxDocType>, b: CRDTOperation<RxDocType>) {\r\n    return a.creator > b.creator ? 1 : -1;\r\n}\r\n\r\n\r\nfunction runOperationOnDocument<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    docData: WithDeleted<RxDocType>,\r\n    operation: CRDTOperation<RxDocType>\r\n): WithDeleted<RxDocType> {\r\n    const entryParts = operation.body;\r\n    entryParts.forEach(entryPart => {\r\n        let isMatching: boolean;\r\n        if (entryPart.selector) {\r\n            const query: FilledMangoQuery<RxDocType> = {\r\n                selector: ensureNotFalsy(entryPart.selector as any),\r\n                sort: [],\r\n                skip: 0\r\n            };\r\n            const matcher = getQueryMatcher(schema, query);\r\n            isMatching = matcher(docData as any);\r\n        } else {\r\n            isMatching = true;\r\n        }\r\n        if (isMatching) {\r\n            if (entryPart.ifMatch) {\r\n                docData = mingoUpdater<WithDeleted<RxDocType>>(docData, entryPart.ifMatch);\r\n            }\r\n        } else {\r\n            if (entryPart.ifNotMatch) {\r\n                docData = mingoUpdater<WithDeleted<RxDocType>>(docData, entryPart.ifNotMatch);\r\n            }\r\n        }\r\n    });\r\n    return docData;\r\n}\r\n\r\nexport async function hashCRDTOperations(\r\n    hashFunction: HashFunction,\r\n    crdts: CRDTDocumentField<any>\r\n): Promise<string> {\r\n    const hashObj = crdts.operations.map((operations) => {\r\n        return operations.map(op => op.creator);\r\n    });\r\n    const hash = await hashFunction(JSON.stringify(hashObj));\r\n    return hash;\r\n}\r\n\r\nexport function getCRDTSchemaPart<RxDocType>(): JsonSchema<CRDTDocumentField<RxDocType>> {\r\n    const operationSchema: JsonSchema<CRDTOperation<RxDocType>> = {\r\n        type: 'object',\r\n        properties: {\r\n            body: {\r\n                type: 'array',\r\n                items: {\r\n                    type: 'object',\r\n                    properties: {\r\n                        selector: {\r\n                            type: 'object'\r\n                        },\r\n                        ifMatch: {\r\n                            type: 'object'\r\n                        },\r\n                        ifNotMatch: {\r\n                            type: 'object'\r\n                        }\r\n                    },\r\n                    additionalProperties: false\r\n                },\r\n                minItems: 1\r\n            },\r\n            creator: {\r\n                type: 'string'\r\n            },\r\n            time: {\r\n                type: 'number',\r\n                minimum: 1,\r\n                maximum: 1000000000000000,\r\n                multipleOf: 0.01\r\n            }\r\n        },\r\n        additionalProperties: false,\r\n        required: [\r\n            'body',\r\n            'creator',\r\n            'time'\r\n        ]\r\n    };\r\n    return {\r\n        type: 'object',\r\n        properties: {\r\n            operations: {\r\n                type: 'array',\r\n                items: {\r\n                    type: 'array',\r\n                    items: operationSchema\r\n                }\r\n            },\r\n            hash: {\r\n                type: 'string',\r\n                // set a minLength to not accidentally store an empty string\r\n                minLength: 2\r\n            }\r\n        },\r\n        additionalProperties: false,\r\n        required: ['operations', 'hash']\r\n    };\r\n}\r\n\r\n\r\nexport async function mergeCRDTFields<RxDocType>(\r\n    hashFunction: HashFunction,\r\n    crdtsA: CRDTDocumentField<RxDocType>,\r\n    crdtsB: CRDTDocumentField<RxDocType>\r\n): Promise<CRDTDocumentField<RxDocType>> {\r\n\r\n    // the value with most operations must be A to\r\n    // ensure we not miss out rows when iterating over both fields.\r\n    if (crdtsA.operations.length < crdtsB.operations.length) {\r\n        [crdtsA, crdtsB] = [crdtsB, crdtsA];\r\n    }\r\n\r\n    const ret: CRDTDocumentField<RxDocType> = {\r\n        operations: [],\r\n        hash: ''\r\n    };\r\n    crdtsA.operations.forEach((row, index) => {\r\n        let mergedOps: CRDTOperation<RxDocType>[] = [];\r\n        const ids = new Set<string>(); // used to deduplicate\r\n\r\n        row.forEach(op => {\r\n            ids.add(op.creator);\r\n            mergedOps.push(op);\r\n        });\r\n        if (crdtsB.operations[index]) {\r\n            crdtsB.operations[index].forEach(op => {\r\n                if (!ids.has(op.creator)) {\r\n                    mergedOps.push(op);\r\n                }\r\n            });\r\n        }\r\n        mergedOps = mergedOps.sort(sortOperationComparator);\r\n        ret.operations[index] = mergedOps;\r\n    });\r\n\r\n\r\n    ret.hash = await hashCRDTOperations(hashFunction, ret);\r\n    return ret;\r\n}\r\n\r\nexport function rebuildFromCRDT<RxDocType>(\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\r\n    docData: WithDeleted<RxDocType> | RxDocType,\r\n    crdts: CRDTDocumentField<RxDocType>\r\n): WithDeleted<RxDocType> {\r\n    let base: WithDeleted<RxDocType> = {\r\n        _deleted: false\r\n    } as any;\r\n    setProperty(base, ensureNotFalsy(schema.crdt).field, crdts);\r\n    crdts.operations.forEach(operations => {\r\n        operations.forEach(op => {\r\n            base = runOperationOnDocument(\r\n                schema,\r\n                base,\r\n                op\r\n            );\r\n        });\r\n    });\r\n    return base;\r\n}\r\n\r\n\r\nexport function getCRDTConflictHandler<RxDocType>(\r\n    hashFunction: HashFunction,\r\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>\r\n): RxConflictHandler<RxDocType> {\r\n    const crdtOptions = ensureNotFalsy(schema.crdt);\r\n    const crdtField = crdtOptions.field;\r\n    const getCRDTValue = objectPathMonad<WithDeleted<RxDocType> | RxDocType, CRDTDocumentField<RxDocType>>(crdtField);\r\n\r\n    const conflictHandler: RxConflictHandler<RxDocType> = async (\r\n        i: RxConflictHandlerInput<RxDocType>,\r\n        _context: string\r\n    ) => {\r\n        const newDocCrdt = getCRDTValue(i.newDocumentState);\r\n        const masterDocCrdt = getCRDTValue(i.realMasterState);\r\n\r\n        if (newDocCrdt.hash === masterDocCrdt.hash) {\r\n            return Promise.resolve({\r\n                isEqual: true\r\n            });\r\n        }\r\n\r\n        const mergedCrdt = await mergeCRDTFields(hashFunction, newDocCrdt, masterDocCrdt);\r\n        const mergedDoc = rebuildFromCRDT(\r\n            schema,\r\n            i.newDocumentState,\r\n            mergedCrdt\r\n        );\r\n        return Promise.resolve({\r\n            isEqual: false,\r\n            documentData: mergedDoc\r\n        });\r\n    };\r\n\r\n    return conflictHandler;\r\n}\r\n\r\n\r\nexport const RX_CRDT_CONTEXT = 'rx-crdt';\r\n\r\nexport const RxDBcrdtPlugin: RxPlugin = {\r\n    name: 'crdt',\r\n    rxdb: true,\r\n    prototypes: {\r\n        RxDocument: (proto: any) => {\r\n            proto.updateCRDT = updateCRDT;\r\n\r\n            const oldRemove = proto.remove;\r\n            proto.remove = function (this: RxDocument) {\r\n                if (!this.collection.schema.jsonSchema.crdt) {\r\n                    return oldRemove.bind(this)();\r\n                }\r\n                return this.updateCRDT({\r\n                    ifMatch: {\r\n                        $set: {\r\n                            _deleted: true\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n\r\n            const oldincrementalPatch = proto.incrementalPatch;\r\n            proto.incrementalPatch = function (this: RxDocument, patch: any) {\r\n                if (!this.collection.schema.jsonSchema.crdt) {\r\n                    return oldincrementalPatch.bind(this)(patch);\r\n                }\r\n                return this.updateCRDT({\r\n                    ifMatch: {\r\n                        $set: patch\r\n                    }\r\n                });\r\n            };\r\n            const oldincrementalModify = proto.incrementalModify;\r\n            proto.incrementalModify = function (fn: any, context: string) {\r\n                if (!this.collection.schema.jsonSchema.crdt) {\r\n                    return oldincrementalModify.bind(this)(fn);\r\n                }\r\n                if (context === RX_CRDT_CONTEXT) {\r\n                    return oldincrementalModify.bind(this)(fn);\r\n                } else {\r\n                    throw newRxError('CRDT2', {\r\n                        id: this.primary,\r\n                        args: { context }\r\n                    });\r\n                }\r\n            };\r\n        },\r\n        RxCollection: (proto: any) => {\r\n            proto.insertCRDT = insertCRDT;\r\n        }\r\n    },\r\n    overwritable: {},\r\n    hooks: {\r\n        preCreateRxCollection: {\r\n            after: (data) => {\r\n                if (!data.schema.crdt) {\r\n                    return;\r\n                }\r\n                if (data.conflictHandler) {\r\n                    throw newRxError('CRDT3', {\r\n                        collection: data.name,\r\n                        schema: data.schema\r\n                    });\r\n                }\r\n                data.conflictHandler = getCRDTConflictHandler(\r\n                    data.database.hashFunction,\r\n                    data.schema\r\n                );\r\n            }\r\n        },\r\n        createRxCollection: {\r\n            after: ({ collection }) => {\r\n                if (!collection.schema.jsonSchema.crdt) {\r\n                    return;\r\n                }\r\n\r\n                const crdtOptions = ensureNotFalsy(collection.schema.jsonSchema.crdt);\r\n                const crdtField = crdtOptions.field;\r\n                const getCrdt = objectPathMonad<any, CRDTDocumentField<any>>(crdtOptions.field);\r\n\r\n                /**\r\n                 * In dev-mode we have to ensure that all document writes\r\n                 * have the correct crdt state so that nothing is missed out\r\n                 * or could accidentally do non-crdt writes to the document.\r\n                 */\r\n                if (overwritable.isDevMode()) {\r\n                    const bulkWriteBefore = collection.storageInstance.bulkWrite.bind(collection.storageInstance);\r\n                    collection.storageInstance.bulkWrite = async function (writes, context) {\r\n\r\n                        await Promise.all(\r\n                            writes.map(async (write) => {\r\n                                const newDocState: typeof write.document = clone(write.document);\r\n                                const crdts = getCrdt(newDocState);\r\n\r\n                                const rebuild = rebuildFromCRDT(\r\n                                    collection.schema.jsonSchema,\r\n                                    newDocState,\r\n                                    crdts\r\n                                );\r\n\r\n                                function docWithoutMeta(doc: any) {\r\n                                    const ret: any = {};\r\n                                    Object.entries(doc).forEach(([k, v]) => {\r\n                                        if (\r\n                                            !k.startsWith('_') &&\r\n                                            typeof v !== 'undefined'\r\n                                        ) {\r\n                                            ret[k] = v;\r\n                                        }\r\n                                    });\r\n                                    return ret;\r\n                                }\r\n                                if (!deepEqual(docWithoutMeta(newDocState), docWithoutMeta(rebuild))) {\r\n                                    throw newRxError('SNH', {\r\n                                        document: newDocState\r\n                                    });\r\n                                }\r\n                                const recalculatedHash = await hashCRDTOperations(collection.database.hashFunction, crdts);\r\n                                if (crdts.hash !== recalculatedHash) {\r\n                                    throw newRxError('SNH', {\r\n                                        document: newDocState,\r\n                                        args: { hash: crdts.hash, recalculatedHash }\r\n                                    });\r\n                                }\r\n                            })\r\n                        );\r\n\r\n                        return bulkWriteBefore(writes, context);\r\n                    };\r\n                }\r\n\r\n\r\n                const bulkInsertBefore = collection.bulkInsert.bind(collection);\r\n                collection.bulkInsert = async function (docsData: any[]) {\r\n                    const storageToken = await collection.database.storageToken;\r\n                    const useDocsData = await Promise.all(\r\n                        docsData.map(async (docData) => {\r\n                            const setMe: Partial<RxDocumentData<any>> = {};\r\n                            Object.entries(docData).forEach(([key, value]) => {\r\n                                if (\r\n                                    !key.startsWith('_') &&\r\n                                    key !== crdtField\r\n                                ) {\r\n                                    setMe[key] = value;\r\n                                }\r\n                            });\r\n\r\n                            const crdtOperations: CRDTDocumentField<any> = {\r\n                                operations: [\r\n                                    [{\r\n                                        creator: storageToken,\r\n                                        body: [{\r\n                                            ifMatch: {\r\n                                                $set: setMe\r\n                                            }\r\n                                        }],\r\n                                        time: now()\r\n                                    }]\r\n                                ],\r\n                                hash: ''\r\n                            };\r\n                            crdtOperations.hash = await hashCRDTOperations(collection.database.hashFunction, crdtOperations);\r\n                            setProperty(docData, crdtOptions.field, crdtOperations);\r\n                            return docData;\r\n                        })\r\n                    );\r\n                    return bulkInsertBefore(useDocsData);\r\n                };\r\n            }\r\n        }\r\n    }\r\n};\r\n"],"mappings":"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","ignoreList":[]}